import { Request, Response, NextFunction } from 'express';
import { vulnerabilityService } from '../services/VulnerabilityService';
import { ApiResponse } from '../types';
import { AppError } from '../middleware/errorHandler';

export class VulnerabilityController {
  // GET /api/v1/vulnerabilities
  async getVulnerabilities(req: Request, res: Response<ApiResponse>, next: NextFunction) {
    try {
      const options = {
        page: parseInt(req.query.page as string) || 1,
        limit: parseInt(req.query.limit as string) || 10,
        sort: req.query.sort as string || '-fechaDeteccion',
        filter: {
          categoria: req.query.categoria,
          estado: req.query.estado,
          facilidad: req.query.facilidad,
          search: req.query.search
        }
      };

      const result = await vulnerabilityService.getVulnerabilities(options);

      res.json({
        success: true,
        data: result.vulnerabilities,
        pagination: result.pagination
      });
    } catch (error) {
      next(error);
    }
  }

  // GET /api/v1/vulnerabilities/:id
  async getVulnerabilityById(req: Request, res: Response<ApiResponse>, next: NextFunction) {
    try {
      const vulnerability = await vulnerabilityService.getVulnerabilityById(req.params.id);
      
      res.json({
        success: true,
        data: vulnerability
      });
    } catch (error) {
      next(error);
    }
  }

  // POST /api/v1/vulnerabilities
  async createVulnerability(req: Request, res: Response<ApiResponse>, next: NextFunction) {
    try {
      const vulnerability = await vulnerabilityService.createVulnerability(req.body);
      
      res.status(201).json({
        success: true,
        data: vulnerability,
        message: 'Vulnerabilidad creada exitosamente'
      });
    } catch (error) {
      next(error);
    }
  }

  // PUT /api/v1/vulnerabilities/:id
  async updateVulnerability(req: Request, res: Response<ApiResponse>, next: NextFunction) {
    try {
      const vulnerability = await vulnerabilityService.updateVulnerability(req.params.id, req.body);
      
      res.json({
        success: true,
        data: vulnerability,
        message: 'Vulnerabilidad actualizada exitosamente'
      });
    } catch (error) {
      next(error);
    }
  }

  // DELETE /api/v1/vulnerabilities/:id
  async deleteVulnerability(req: Request, res: Response<ApiResponse>, next: NextFunction) {
    try {
      await vulnerabilityService.deleteVulnerability(req.params.id);
      
      res.json({
        success: true,
        message: 'Vulnerabilidad eliminada exitosamente'
      });
    } catch (error) {
      next(error);
    }
  }

  // GET /api/v1/vulnerabilities/categoria/:categoria
  async getVulnerabilitiesByCategoria(req: Request, res: Response<ApiResponse>, next: NextFunction) {
    try {
      const { categoria } = req.params;
      const vulnerabilities = await vulnerabilityService.getVulnerabilitiesByCategoria(categoria);
      
      res.json({
        success: true,
        data: vulnerabilities
      });
    } catch (error) {
      next(error);
    }
  }

  // GET /api/v1/vulnerabilities/activo/:assetId
  async getVulnerabilitiesForAsset(req: Request, res: Response<ApiResponse>, next: NextFunction) {
    try {
      const { assetId } = req.params;
      const vulnerabilities = await vulnerabilityService.getVulnerabilitiesForAsset(assetId);
      
      res.json({
        success: true,
        data: vulnerabilities,
        message: `${vulnerabilities.length} vulnerabilidades encontradas para el activo`
      });
    } catch (error) {
      next(error);
    }
  }

  // GET /api/v1/vulnerabilities/stats
  async getVulnerabilityStats(req: Request, res: Response<ApiResponse>, next: NextFunction) {
    try {
      const stats = await vulnerabilityService.getVulnerabilityStats();
      
      res.json({
        success: true,
        data: stats
      });
    } catch (error) {
      next(error);
    }
  }

  // POST /api/v1/vulnerabilities/:id/mitigate
  async mitigateVulnerability(req: Request, res: Response<ApiResponse>, next: NextFunction) {
    try {
      const { id } = req.params;
      const { fechaMitigacion, observaciones } = req.body;
      
      const vulnerability = await vulnerabilityService.mitigateVulnerability(
        id, 
        fechaMitigacion ? new Date(fechaMitigacion) : new Date(),
        observaciones
      );
      
      res.json({
        success: true,
        data: vulnerability,
        message: 'Vulnerabilidad mitigada exitosamente'
      });
    } catch (error) {
      next(error);
    }
  }

  // POST /api/v1/vulnerabilities/:id/reopen
  async reopenVulnerability(req: Request, res: Response<ApiResponse>, next: NextFunction) {
    try {
      const { id } = req.params;
      const vulnerability = await vulnerabilityService.reopenVulnerability(id);
      
      res.json({
        success: true,
        data: vulnerability,
        message: 'Vulnerabilidad reabierta exitosamente'
      });
    } catch (error) {
      next(error);
    }
  }

  // GET /api/v1/vulnerabilities/critical
  async getCriticalVulnerabilities(req: Request, res: Response<ApiResponse>, next: NextFunction) {
    try {
      const vulnerabilities = await vulnerabilityService.getCriticalVulnerabilities();
      
      res.json({
        success: true,
        data: vulnerabilities,
        message: `${vulnerabilities.length} vulnerabilidades críticas encontradas`
      });
    } catch (error) {
      next(error);
    }
  }

  // POST /api/v1/vulnerabilities/scan/:assetId
  async scanAssetVulnerabilities(req: Request, res: Response<ApiResponse>, next: NextFunction) {
    try {
      const { assetId } = req.params;
      const { scanType = 'basic' } = req.body;
      
      const result = await vulnerabilityService.scanAssetVulnerabilities(assetId, scanType);
      
      res.json({
        success: true,
        data: result,
        message: 'Escaneo de vulnerabilidades completado'
      });
    } catch (error) {
      next(error);
    }
  }

  // GET /api/v1/vulnerabilities/dashboard
  async getDashboardStats(req: Request, res: Response<ApiResponse>, next: NextFunction) {
    try {
      const stats = await vulnerabilityService.getDashboardStats();
      
      res.json({
        success: true,
        data: stats
      });
    } catch (error) {
      next(error);
    }
  }

  // POST /api/v1/vulnerabilities/bulk-action
  async bulkAction(req: Request, res: Response<ApiResponse>, next: NextFunction) {
    try {
      const { action, vulnerabilityIds, data } = req.body;
      
      if (!action || !Array.isArray(vulnerabilityIds) || vulnerabilityIds.length === 0) {
        throw new AppError('Acción y lista de vulnerabilidades son requeridos', 400);
      }

      const result = await vulnerabilityService.bulkAction(action, vulnerabilityIds, data);
      
      res.json({
        success: true,
        data: result,
        message: `Acción en lote completada: ${result.processed} procesadas, ${result.errors} errores`
      });
    } catch (error) {
      next(error);
    }
  }
}

export const vulnerabilityController = new VulnerabilityController();