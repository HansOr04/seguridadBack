import { Vulnerability } from '../models/Vulnerability';
import { Asset } from '../models/Asset';
import { Threat } from '../models/Threat';
import { IVulnerability, PaginationOptions } from '../types';
import { AppError } from '../middleware/errorHandler';
import logger from '../utils/logger';

export class VulnerabilityService {
  // Crear nueva vulnerabilidad
  async createVulnerability(vulnerabilityData: Partial<IVulnerability>): Promise<IVulnerability> {
    try {
      // Verificar si el código ya existe
      const existingVulnerability = await Vulnerability.findOne({ codigo: vulnerabilityData.codigo });
      if (existingVulnerability) {
        throw new AppError('El código de vulnerabilidad ya existe', 400);
      }

      const vulnerability = new Vulnerability(vulnerabilityData);
      await vulnerability.save();
      
      logger.info(`Vulnerabilidad creada: ${vulnerability.codigo}`);
      return vulnerability;
    } catch (error) {
      logger.error('Error creando vulnerabilidad:', error);
      throw error;
    }
  }

  // Obtener lista paginada de vulnerabilidades
  async getVulnerabilities(options: PaginationOptions): Promise<{
    vulnerabilities: IVulnerability[];
    pagination: any;
  }> {
    try {
      const { page = 1, limit = 10, sort = '-fechaDeteccion', filter = {} } = options;
      
      const skip = (page - 1) * limit;
      
      // Construir filtros
      const query: any = {};
      if (filter.categoria) query.categoria = filter.categoria;
      if (filter.estado) query.estado = filter.estado;
      if (filter.facilidad) {
        const facilidad = parseInt(filter.facilidad);
        query.facilidadExplotacion = { $gte: facilidad, $lt: facilidad + 1 };
      }
      if (filter.search) {
        query.$or = [
          { nombre: new RegExp(filter.search, 'i') },
          { codigo: new RegExp(filter.search, 'i') },
          { descripcion: new RegExp(filter.search, 'i') }
        ];
      }

      const [vulnerabilities, total] = await Promise.all([
        Vulnerability.find(query)
          .populate('afectaA', 'codigo nombre tipo')
          .populate('amenazasRelacionadas', 'codigo nombre tipo')
          .sort(sort)
          .skip(skip)
          .limit(limit)
          .lean(),
        Vulnerability.countDocuments(query)
      ]);

      return {
        vulnerabilities: vulnerabilities as IVulnerability[],
        pagination: {
          page,
          limit,
          total,
          pages: Math.ceil(total / limit)
        }
      };
    } catch (error) {
      logger.error('Error obteniendo vulnerabilidades:', error);
      throw error;
    }
  }

  // Obtener vulnerabilidad por ID
  async getVulnerabilityById(id: string): Promise<IVulnerability> {
    try {
      const vulnerability = await Vulnerability.findById(id)
        .populate('afectaA', 'codigo nombre tipo valorEconomico')
        .populate('amenazasRelacionadas', 'codigo nombre tipo probabilidad')
        .lean();

      if (!vulnerability) {
        throw new AppError('Vulnerabilidad no encontrada', 404);
      }

      return vulnerability as IVulnerability;
    } catch (error) {
      logger.error(`Error obteniendo vulnerabilidad ${id}:`, error);
      throw error;
    }
  }

  // Actualizar vulnerabilidad
  async updateVulnerability(id: string, updateData: Partial<IVulnerability>): Promise<IVulnerability> {
    try {
      // Si se está actualizando el código, verificar que no exista
      if (updateData.codigo) {
        const existingVulnerability = await Vulnerability.findOne({ 
          codigo: updateData.codigo, 
          _id: { $ne: id } 
        });
        if (existingVulnerability) {
          throw new AppError('El código de vulnerabilidad ya existe', 400);
        }
      }

      const vulnerability = await Vulnerability.findByIdAndUpdate(
        id,
        updateData,
        { new: true, runValidators: true }
      ).populate('afectaA amenazasRelacionadas');

      if (!vulnerability) {
        throw new AppError('Vulnerabilidad no encontrada', 404);
      }

      logger.info(`Vulnerabilidad actualizada: ${vulnerability.codigo}`);
      return vulnerability;
    } catch (error) {
      logger.error(`Error actualizando vulnerabilidad ${id}:`, error);
      throw error;
    }
  }

  // Eliminar vulnerabilidad
  async deleteVulnerability(id: string): Promise<void> {
    try {
      const vulnerability = await Vulnerability.findByIdAndDelete(id);
      if (!vulnerability) {
        throw new AppError('Vulnerabilidad no encontrada', 404);
      }

      logger.info(`Vulnerabilidad eliminada: ${vulnerability.codigo}`);
    } catch (error) {
      logger.error(`Error eliminando vulnerabilidad ${id}:`, error);
      throw error;
    }
  }

  // Obtener vulnerabilidades por categoría
  async getVulnerabilitiesByCategoria(categoria: string): Promise<IVulnerability[]> {
    try {
      return await Vulnerability.find({ categoria })
        .populate('afectaA', 'codigo nombre')
        .sort({ facilidadExplotacion: -1 })
        .lean() as IVulnerability[];
    } catch (error) {
      logger.error(`Error obteniendo vulnerabilidades por categoría ${categoria}:`, error);
      throw error;
    }
  }

  // Obtener vulnerabilidades para un activo específico
  async getVulnerabilitiesForAsset(assetId: string): Promise<IVulnerability[]> {
    try {
      // Verificar que el activo existe
      const asset = await Asset.findById(assetId);
      if (!asset) {
        throw new AppError('Activo no encontrado', 404);
      }

      const vulnerabilities = await Vulnerability.find({ afectaA: assetId })
        .populate('amenazasRelacionadas', 'codigo nombre probabilidad')
        .sort({ facilidadExplotacion: -1 })
        .lean();

      return vulnerabilities as IVulnerability[];
    } catch (error) {
      logger.error(`Error obteniendo vulnerabilidades para activo ${assetId}:`, error);
      throw error;
    }
  }

  // Obtener estadísticas de vulnerabilidades
  async getVulnerabilityStats(): Promise<any> {
    try {
      const stats = await Vulnerability.aggregate([
        {
          $group: {
            _id: null,
            totalVulnerabilidades: { $sum: 1 },
            facilidadPromedio: { $avg: '$facilidadExplotacion' },
            vulnerabilidadesCriticas: {
              $sum: { $cond: [{ $gte: ['$facilidadExplotacion', 8] }, 1, 0] }
            },
            vulnerabilidadesAltas: {
              $sum: { $cond: [{ $and: [{ $gte: ['$facilidadExplotacion', 6] }, { $lt: ['$facilidadExplotacion', 8] }] }, 1, 0] }
            }
          }
        }
      ]);

      const estadoStats = await Vulnerability.aggregate([
        {
          $group: {
            _id: '$estado',
            count: { $sum: 1 }
          }
        }
      ]);

      const categoriaStats = await Vulnerability.aggregate([
        {
          $group: {
            _id: '$categoria',
            count: { $sum: 1 },
            facilidadPromedio: { $avg: '$facilidadExplotacion' }
          }
        }
      ]);

      return {
        general: stats[0] || { 
          totalVulnerabilidades: 0, 
          facilidadPromedio: 0, 
          vulnerabilidadesCriticas: 0, 
          vulnerabilidadesAltas: 0 
        },
        porEstado: estadoStats,
        porCategoria: categoriaStats
      };
    } catch (error) {
      logger.error('Error obteniendo estadísticas de vulnerabilidades:', error);
      throw error;
    }
  }

  // Mitigar vulnerabilidad
  async mitigateVulnerability(
    id: string, 
    fechaMitigacion: Date, 
    observaciones?: string
  ): Promise<IVulnerability> {
    try {
      const vulnerability = await Vulnerability.findById(id);
      if (!vulnerability) {
        throw new AppError('Vulnerabilidad no encontrada', 404);
      }

      vulnerability.estado = 'Mitigada';
      vulnerability.fechaMitigacion = fechaMitigacion;

      await vulnerability.save();
      await vulnerability.populate('afectaA amenazasRelacionadas');

      logger.info(`Vulnerabilidad mitigada: ${vulnerability.codigo}`);
      return vulnerability;
    } catch (error) {
      logger.error(`Error mitigando vulnerabilidad ${id}:`, error);
      throw error;
    }
  }

  // Reabrir vulnerabilidad
  async reopenVulnerability(id: string): Promise<IVulnerability> {
    try {
      const vulnerability = await Vulnerability.findById(id);
      if (!vulnerability) {
        throw new AppError('Vulnerabilidad no encontrada', 404);
      }

      vulnerability.estado = 'Activa';
      vulnerability.fechaMitigacion = undefined;

      await vulnerability.save();
      await vulnerability.populate('afectaA amenazasRelacionadas');

      logger.info(`Vulnerabilidad reabierta: ${vulnerability.codigo}`);
      return vulnerability;
    } catch (error) {
      logger.error(`Error reabriendo vulnerabilidad ${id}:`, error);
      throw error;
    }
  }

  // Obtener vulnerabilidades críticas
  async getCriticalVulnerabilities(): Promise<IVulnerability[]> {
    try {
      return await Vulnerability.find({ 
        facilidadExplotacion: { $gte: 8 },
        estado: { $in: ['Activa', 'En Tratamiento'] }
      })
        .populate('afectaA', 'codigo nombre valorEconomico')
        .populate('amenazasRelacionadas', 'codigo nombre probabilidad')
        .sort({ facilidadExplotacion: -1 })
        .lean() as IVulnerability[];
    } catch (error) {
      logger.error('Error obteniendo vulnerabilidades críticas:', error);
      throw error;
    }
  }

  // Escanear vulnerabilidades de un activo (simulación básica)
  async scanAssetVulnerabilities(
    assetId: string, 
    scanType: 'basic' | 'comprehensive' = 'basic'
  ): Promise<{
    newVulnerabilities: number;
    confirmedVulnerabilities: number;
    mitigatedVulnerabilities: number;
  }> {
    try {
      const asset = await Asset.findById(assetId);
      if (!asset) {
        throw new AppError('Activo no encontrado', 404);
      }

      // Simulación de escaneo - en un proyecto real esto se integraría con herramientas de escaneo
      const results = {
        newVulnerabilities: 0,
        confirmedVulnerabilities: 0,
        mitigatedVulnerabilities: 0
      };

      // Obtener vulnerabilidades existentes para el activo
      const existingVulnerabilities = await Vulnerability.find({ afectaA: assetId });
      results.confirmedVulnerabilities = existingVulnerabilities.length;

      // Simulación de nuevas vulnerabilidades encontradas
      if (scanType === 'comprehensive') {
        // Generar vulnerabilidades de ejemplo basadas en el tipo de activo
        const newVulnerabilities = await this.generateSampleVulnerabilities(asset, existingVulnerabilities.length);
        results.newVulnerabilities = newVulnerabilities.length;

        // Guardar nuevas vulnerabilidades
        for (const vulnData of newVulnerabilities) {
          await this.createVulnerability(vulnData);
        }
      }

      logger.info(`Escaneo de vulnerabilidades completado para activo ${asset.codigo}: ${results.newVulnerabilities} nuevas, ${results.confirmedVulnerabilities} confirmadas`);
      return results;
    } catch (error) {
      logger.error(`Error escaneando vulnerabilidades del activo ${assetId}:`, error);
      throw error;
    }
  }

  // Generar vulnerabilidades de ejemplo (para simulación)
  private async generateSampleVulnerabilities(asset: any, existingCount: number): Promise<Partial<IVulnerability>[]> {
    const vulnerabilities: Partial<IVulnerability>[] = [];

    if (asset.tipo === 'Software') {
      vulnerabilities.push({
        codigo: `VULN-${asset.codigo}-${existingCount + 1}`,
        nombre: 'Versión desactualizada del software',
        categoria: 'Configuración',
        descripcion: 'El software no tiene las últimas actualizaciones de seguridad',
        facilidadExplotacion: 6,
        vectoresAtaque: ['Red', 'Local'],
        afectaA: [asset._id],
        estado: 'Activa'
      });
    }

    if (asset.tipo === 'Hardware') {
      vulnerabilities.push({
        codigo: `VULN-${asset.codigo}-${existingCount + 2}`,
        nombre: 'Firmware obsoleto',
        categoria: 'Hardware',
        descripcion: 'El firmware del dispositivo contiene vulnerabilidades conocidas',
        facilidadExplotacion: 5,
        vectoresAtaque: ['Físico', 'Red'],
        afectaA: [asset._id],
        estado: 'Activa'
      });
    }

    return vulnerabilities;
  }

  // Obtener estadísticas del dashboard
  async getDashboardStats(): Promise<any> {
    try {
      const [generalStats, recentVulnerabilities, activeVulnerabilities] = await Promise.all([
        this.getVulnerabilityStats(),
        Vulnerability.find({ 
          fechaDeteccion: { $gte: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000) }
        }).countDocuments(),
        Vulnerability.find({ estado: 'Activa' }).countDocuments()
      ]);

      return {
        ...generalStats.general,
        vulnerabilidadesRecientes: recentVulnerabilities,
        vulnerabilidadesActivas: activeVulnerabilities,
        distribucion: {
          porEstado: generalStats.porEstado,
          porCategoria: generalStats.porCategoria
        }
      };
    } catch (error) {
      logger.error('Error obteniendo estadísticas del dashboard:', error);
      throw error;
    }
  }

  // Acción en lote sobre vulnerabilidades
  async bulkAction(
    action: 'mitigate' | 'reopen' | 'delete',
    vulnerabilityIds: string[],
    data?: any
  ): Promise<{
    processed: number;
    errors: number;
    results: any[];
  }> {
    const results = {
      processed: 0,
      errors: 0,
      results: [] as any[]
    };

    for (const id of vulnerabilityIds) {
      try {
        let result;
        switch (action) {
          case 'mitigate':
            result = await this.mitigateVulnerability(id, data?.fechaMitigacion || new Date(), data?.observaciones);
            break;
          case 'reopen':
            result = await this.reopenVulnerability(id);
            break;
          case 'delete':
            await this.deleteVulnerability(id);
            result = { id, deleted: true };
            break;
          default:
            throw new Error(`Acción no válida: ${action}`);
        }
        
        results.processed++;
        results.results.push(result);
      } catch (error) {
        results.errors++;
        results.results.push({ id, error: (error as Error).message });
      }
    }

    logger.info(`Acción en lote '${action}' completada: ${results.processed} procesadas, ${results.errors} errores`);
    return results;
  }
}

export const vulnerabilityService = new VulnerabilityService();